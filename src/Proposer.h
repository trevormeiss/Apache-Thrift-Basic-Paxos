/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Proposer_H
#define Proposer_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "keyvaluestore_types.h"

namespace keyvaluestore {

#ifdef _WIN32
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class ProposerIf {
 public:
  virtual ~ProposerIf() {}
  virtual bool hello(const ServerAddress& serverAddress) = 0;
  virtual bool goodbye(const ServerAddress& serverAddress) = 0;
  virtual void prepare(ProposalValue& _return, const ProposalNumber& propNum) = 0;
  virtual void accept(ProposalNumber& _return, const ProposalValue& propVal) = 0;
  virtual void commit(Request& _return, const Request& request) = 0;
};

class ProposerIfFactory {
 public:
  typedef ProposerIf Handler;

  virtual ~ProposerIfFactory() {}

  virtual ProposerIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(ProposerIf* /* handler */) = 0;
};

class ProposerIfSingletonFactory : virtual public ProposerIfFactory {
 public:
  ProposerIfSingletonFactory(const boost::shared_ptr<ProposerIf>& iface) : iface_(iface) {}
  virtual ~ProposerIfSingletonFactory() {}

  virtual ProposerIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(ProposerIf* /* handler */) {}

 protected:
  boost::shared_ptr<ProposerIf> iface_;
};

class ProposerNull : virtual public ProposerIf {
 public:
  virtual ~ProposerNull() {}
  bool hello(const ServerAddress& /* serverAddress */) {
    bool _return = false;
    return _return;
  }
  bool goodbye(const ServerAddress& /* serverAddress */) {
    bool _return = false;
    return _return;
  }
  void prepare(ProposalValue& /* _return */, const ProposalNumber& /* propNum */) {
    return;
  }
  void accept(ProposalNumber& /* _return */, const ProposalValue& /* propVal */) {
    return;
  }
  void commit(Request& /* _return */, const Request& /* request */) {
    return;
  }
};

typedef struct _Proposer_hello_args__isset {
  _Proposer_hello_args__isset() : serverAddress(false) {}
  bool serverAddress :1;
} _Proposer_hello_args__isset;

class Proposer_hello_args {
 public:

  Proposer_hello_args(const Proposer_hello_args&);
  Proposer_hello_args& operator=(const Proposer_hello_args&);
  Proposer_hello_args() {
  }

  virtual ~Proposer_hello_args() throw();
  ServerAddress serverAddress;

  _Proposer_hello_args__isset __isset;

  void __set_serverAddress(const ServerAddress& val);

  bool operator == (const Proposer_hello_args & rhs) const
  {
    if (!(serverAddress == rhs.serverAddress))
      return false;
    return true;
  }
  bool operator != (const Proposer_hello_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Proposer_hello_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Proposer_hello_pargs {
 public:


  virtual ~Proposer_hello_pargs() throw();
  const ServerAddress* serverAddress;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Proposer_hello_result__isset {
  _Proposer_hello_result__isset() : success(false) {}
  bool success :1;
} _Proposer_hello_result__isset;

class Proposer_hello_result {
 public:

  Proposer_hello_result(const Proposer_hello_result&);
  Proposer_hello_result& operator=(const Proposer_hello_result&);
  Proposer_hello_result() : success(0) {
  }

  virtual ~Proposer_hello_result() throw();
  bool success;

  _Proposer_hello_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const Proposer_hello_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Proposer_hello_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Proposer_hello_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Proposer_hello_presult__isset {
  _Proposer_hello_presult__isset() : success(false) {}
  bool success :1;
} _Proposer_hello_presult__isset;

class Proposer_hello_presult {
 public:


  virtual ~Proposer_hello_presult() throw();
  bool* success;

  _Proposer_hello_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Proposer_goodbye_args__isset {
  _Proposer_goodbye_args__isset() : serverAddress(false) {}
  bool serverAddress :1;
} _Proposer_goodbye_args__isset;

class Proposer_goodbye_args {
 public:

  Proposer_goodbye_args(const Proposer_goodbye_args&);
  Proposer_goodbye_args& operator=(const Proposer_goodbye_args&);
  Proposer_goodbye_args() {
  }

  virtual ~Proposer_goodbye_args() throw();
  ServerAddress serverAddress;

  _Proposer_goodbye_args__isset __isset;

  void __set_serverAddress(const ServerAddress& val);

  bool operator == (const Proposer_goodbye_args & rhs) const
  {
    if (!(serverAddress == rhs.serverAddress))
      return false;
    return true;
  }
  bool operator != (const Proposer_goodbye_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Proposer_goodbye_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Proposer_goodbye_pargs {
 public:


  virtual ~Proposer_goodbye_pargs() throw();
  const ServerAddress* serverAddress;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Proposer_goodbye_result__isset {
  _Proposer_goodbye_result__isset() : success(false) {}
  bool success :1;
} _Proposer_goodbye_result__isset;

class Proposer_goodbye_result {
 public:

  Proposer_goodbye_result(const Proposer_goodbye_result&);
  Proposer_goodbye_result& operator=(const Proposer_goodbye_result&);
  Proposer_goodbye_result() : success(0) {
  }

  virtual ~Proposer_goodbye_result() throw();
  bool success;

  _Proposer_goodbye_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const Proposer_goodbye_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Proposer_goodbye_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Proposer_goodbye_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Proposer_goodbye_presult__isset {
  _Proposer_goodbye_presult__isset() : success(false) {}
  bool success :1;
} _Proposer_goodbye_presult__isset;

class Proposer_goodbye_presult {
 public:


  virtual ~Proposer_goodbye_presult() throw();
  bool* success;

  _Proposer_goodbye_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Proposer_prepare_args__isset {
  _Proposer_prepare_args__isset() : propNum(false) {}
  bool propNum :1;
} _Proposer_prepare_args__isset;

class Proposer_prepare_args {
 public:

  Proposer_prepare_args(const Proposer_prepare_args&);
  Proposer_prepare_args& operator=(const Proposer_prepare_args&);
  Proposer_prepare_args() {
  }

  virtual ~Proposer_prepare_args() throw();
  ProposalNumber propNum;

  _Proposer_prepare_args__isset __isset;

  void __set_propNum(const ProposalNumber& val);

  bool operator == (const Proposer_prepare_args & rhs) const
  {
    if (!(propNum == rhs.propNum))
      return false;
    return true;
  }
  bool operator != (const Proposer_prepare_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Proposer_prepare_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Proposer_prepare_pargs {
 public:


  virtual ~Proposer_prepare_pargs() throw();
  const ProposalNumber* propNum;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Proposer_prepare_result__isset {
  _Proposer_prepare_result__isset() : success(false), invalidOp(false) {}
  bool success :1;
  bool invalidOp :1;
} _Proposer_prepare_result__isset;

class Proposer_prepare_result {
 public:

  Proposer_prepare_result(const Proposer_prepare_result&);
  Proposer_prepare_result& operator=(const Proposer_prepare_result&);
  Proposer_prepare_result() {
  }

  virtual ~Proposer_prepare_result() throw();
  ProposalValue success;
  InvalidOperation invalidOp;

  _Proposer_prepare_result__isset __isset;

  void __set_success(const ProposalValue& val);

  void __set_invalidOp(const InvalidOperation& val);

  bool operator == (const Proposer_prepare_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(invalidOp == rhs.invalidOp))
      return false;
    return true;
  }
  bool operator != (const Proposer_prepare_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Proposer_prepare_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Proposer_prepare_presult__isset {
  _Proposer_prepare_presult__isset() : success(false), invalidOp(false) {}
  bool success :1;
  bool invalidOp :1;
} _Proposer_prepare_presult__isset;

class Proposer_prepare_presult {
 public:


  virtual ~Proposer_prepare_presult() throw();
  ProposalValue* success;
  InvalidOperation invalidOp;

  _Proposer_prepare_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Proposer_accept_args__isset {
  _Proposer_accept_args__isset() : propVal(false) {}
  bool propVal :1;
} _Proposer_accept_args__isset;

class Proposer_accept_args {
 public:

  Proposer_accept_args(const Proposer_accept_args&);
  Proposer_accept_args& operator=(const Proposer_accept_args&);
  Proposer_accept_args() {
  }

  virtual ~Proposer_accept_args() throw();
  ProposalValue propVal;

  _Proposer_accept_args__isset __isset;

  void __set_propVal(const ProposalValue& val);

  bool operator == (const Proposer_accept_args & rhs) const
  {
    if (!(propVal == rhs.propVal))
      return false;
    return true;
  }
  bool operator != (const Proposer_accept_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Proposer_accept_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Proposer_accept_pargs {
 public:


  virtual ~Proposer_accept_pargs() throw();
  const ProposalValue* propVal;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Proposer_accept_result__isset {
  _Proposer_accept_result__isset() : success(false), invalidOp(false) {}
  bool success :1;
  bool invalidOp :1;
} _Proposer_accept_result__isset;

class Proposer_accept_result {
 public:

  Proposer_accept_result(const Proposer_accept_result&);
  Proposer_accept_result& operator=(const Proposer_accept_result&);
  Proposer_accept_result() {
  }

  virtual ~Proposer_accept_result() throw();
  ProposalNumber success;
  InvalidOperation invalidOp;

  _Proposer_accept_result__isset __isset;

  void __set_success(const ProposalNumber& val);

  void __set_invalidOp(const InvalidOperation& val);

  bool operator == (const Proposer_accept_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(invalidOp == rhs.invalidOp))
      return false;
    return true;
  }
  bool operator != (const Proposer_accept_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Proposer_accept_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Proposer_accept_presult__isset {
  _Proposer_accept_presult__isset() : success(false), invalidOp(false) {}
  bool success :1;
  bool invalidOp :1;
} _Proposer_accept_presult__isset;

class Proposer_accept_presult {
 public:


  virtual ~Proposer_accept_presult() throw();
  ProposalNumber* success;
  InvalidOperation invalidOp;

  _Proposer_accept_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Proposer_commit_args__isset {
  _Proposer_commit_args__isset() : request(false) {}
  bool request :1;
} _Proposer_commit_args__isset;

class Proposer_commit_args {
 public:

  Proposer_commit_args(const Proposer_commit_args&);
  Proposer_commit_args& operator=(const Proposer_commit_args&);
  Proposer_commit_args() {
  }

  virtual ~Proposer_commit_args() throw();
  Request request;

  _Proposer_commit_args__isset __isset;

  void __set_request(const Request& val);

  bool operator == (const Proposer_commit_args & rhs) const
  {
    if (!(request == rhs.request))
      return false;
    return true;
  }
  bool operator != (const Proposer_commit_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Proposer_commit_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Proposer_commit_pargs {
 public:


  virtual ~Proposer_commit_pargs() throw();
  const Request* request;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Proposer_commit_result__isset {
  _Proposer_commit_result__isset() : success(false), invalidOp(false) {}
  bool success :1;
  bool invalidOp :1;
} _Proposer_commit_result__isset;

class Proposer_commit_result {
 public:

  Proposer_commit_result(const Proposer_commit_result&);
  Proposer_commit_result& operator=(const Proposer_commit_result&);
  Proposer_commit_result() {
  }

  virtual ~Proposer_commit_result() throw();
  Request success;
  InvalidOperation invalidOp;

  _Proposer_commit_result__isset __isset;

  void __set_success(const Request& val);

  void __set_invalidOp(const InvalidOperation& val);

  bool operator == (const Proposer_commit_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(invalidOp == rhs.invalidOp))
      return false;
    return true;
  }
  bool operator != (const Proposer_commit_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Proposer_commit_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Proposer_commit_presult__isset {
  _Proposer_commit_presult__isset() : success(false), invalidOp(false) {}
  bool success :1;
  bool invalidOp :1;
} _Proposer_commit_presult__isset;

class Proposer_commit_presult {
 public:


  virtual ~Proposer_commit_presult() throw();
  Request* success;
  InvalidOperation invalidOp;

  _Proposer_commit_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class ProposerClient : virtual public ProposerIf {
 public:
  ProposerClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  ProposerClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  bool hello(const ServerAddress& serverAddress);
  void send_hello(const ServerAddress& serverAddress);
  bool recv_hello();
  bool goodbye(const ServerAddress& serverAddress);
  void send_goodbye(const ServerAddress& serverAddress);
  bool recv_goodbye();
  void prepare(ProposalValue& _return, const ProposalNumber& propNum);
  void send_prepare(const ProposalNumber& propNum);
  void recv_prepare(ProposalValue& _return);
  void accept(ProposalNumber& _return, const ProposalValue& propVal);
  void send_accept(const ProposalValue& propVal);
  void recv_accept(ProposalNumber& _return);
  void commit(Request& _return, const Request& request);
  void send_commit(const Request& request);
  void recv_commit(Request& _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class ProposerProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<ProposerIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (ProposerProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_hello(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_goodbye(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_prepare(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_accept(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_commit(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  ProposerProcessor(boost::shared_ptr<ProposerIf> iface) :
    iface_(iface) {
    processMap_["hello"] = &ProposerProcessor::process_hello;
    processMap_["goodbye"] = &ProposerProcessor::process_goodbye;
    processMap_["prepare"] = &ProposerProcessor::process_prepare;
    processMap_["accept"] = &ProposerProcessor::process_accept;
    processMap_["commit"] = &ProposerProcessor::process_commit;
  }

  virtual ~ProposerProcessor() {}
};

class ProposerProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  ProposerProcessorFactory(const ::boost::shared_ptr< ProposerIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< ProposerIfFactory > handlerFactory_;
};

class ProposerMultiface : virtual public ProposerIf {
 public:
  ProposerMultiface(std::vector<boost::shared_ptr<ProposerIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~ProposerMultiface() {}
 protected:
  std::vector<boost::shared_ptr<ProposerIf> > ifaces_;
  ProposerMultiface() {}
  void add(boost::shared_ptr<ProposerIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  bool hello(const ServerAddress& serverAddress) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hello(serverAddress);
    }
    return ifaces_[i]->hello(serverAddress);
  }

  bool goodbye(const ServerAddress& serverAddress) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->goodbye(serverAddress);
    }
    return ifaces_[i]->goodbye(serverAddress);
  }

  void prepare(ProposalValue& _return, const ProposalNumber& propNum) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->prepare(_return, propNum);
    }
    ifaces_[i]->prepare(_return, propNum);
    return;
  }

  void accept(ProposalNumber& _return, const ProposalValue& propVal) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->accept(_return, propVal);
    }
    ifaces_[i]->accept(_return, propVal);
    return;
  }

  void commit(Request& _return, const Request& request) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->commit(_return, request);
    }
    ifaces_[i]->commit(_return, request);
    return;
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class ProposerConcurrentClient : virtual public ProposerIf {
 public:
  ProposerConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  ProposerConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  bool hello(const ServerAddress& serverAddress);
  int32_t send_hello(const ServerAddress& serverAddress);
  bool recv_hello(const int32_t seqid);
  bool goodbye(const ServerAddress& serverAddress);
  int32_t send_goodbye(const ServerAddress& serverAddress);
  bool recv_goodbye(const int32_t seqid);
  void prepare(ProposalValue& _return, const ProposalNumber& propNum);
  int32_t send_prepare(const ProposalNumber& propNum);
  void recv_prepare(ProposalValue& _return, const int32_t seqid);
  void accept(ProposalNumber& _return, const ProposalValue& propVal);
  int32_t send_accept(const ProposalValue& propVal);
  void recv_accept(ProposalNumber& _return, const int32_t seqid);
  void commit(Request& _return, const Request& request);
  int32_t send_commit(const Request& request);
  void recv_commit(Request& _return, const int32_t seqid);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _WIN32
  #pragma warning( pop )
#endif

} // namespace

#endif
