/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef keyvaluestore_TYPES_H
#define keyvaluestore_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace keyvaluestore {

struct Operation {
  enum type {
    PUT = 0,
    GET = 1,
    ERASE = 2
  };
};

extern const std::map<int, const char*> _Operation_VALUES_TO_NAMES;

class ProposalNumber;

class Request;

class ProposalValue;

class ServerAddress;

class InvalidOperation;

typedef struct _ProposalNumber__isset {
  _ProposalNumber__isset() : roundNumber(false), serverID(false) {}
  bool roundNumber : 1;
  bool serverID : 1;
} _ProposalNumber__isset;

class ProposalNumber {
public:

  ProposalNumber(const ProposalNumber&);
  ProposalNumber& operator=(const ProposalNumber&);
  ProposalNumber() : roundNumber(0), serverID(0) {
  }

  virtual ~ProposalNumber() throw();
  int64_t roundNumber;
  int16_t serverID;

  _ProposalNumber__isset __isset;

  void __set_roundNumber(const int64_t val);

  void __set_serverID(const int16_t val);

  bool operator == (const ProposalNumber & rhs) const
  {
    if (!(roundNumber == rhs.roundNumber))
      return false;
    if (!(serverID == rhs.serverID))
      return false;
    return true;
  }
  bool operator != (const ProposalNumber &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProposalNumber &rhs) const {
    return this->roundNumber < rhs.roundNumber ||
           (this->roundNumber == rhs.roundNumber &&
            this->serverID < rhs.serverID);
  }

  bool operator > (const ProposalNumber &rhs) const {
    return this->roundNumber > rhs.roundNumber ||
           (this->roundNumber == rhs.roundNumber &&
            this->serverID > rhs.serverID);
  }

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ProposalNumber &a, ProposalNumber &b);

inline std::ostream& operator<<(std::ostream& out, const ProposalNumber& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Request__isset {
  _Request__isset() : op(false), key(false), value(false), comment(false), successful(false) {}
  bool op : 1;
  bool key : 1;
  bool value : 1;
  bool comment : 1;
  bool successful : 1;
} _Request__isset;

class Request {
public:

  Request(const Request&);
  Request& operator=(const Request&);
  Request() : op((Operation::type)0), key(), value(), comment(), successful(0) {
  }

  virtual ~Request() throw();
  Operation::type op;
  std::string key;
  std::string value;
  std::string comment;
  bool successful;

  _Request__isset __isset;

  void __set_op(const Operation::type val);

  void __set_key(const std::string& val);

  void __set_value(const std::string& val);

  void __set_comment(const std::string& val);

  void __set_successful(const bool val);

  bool operator == (const Request & rhs) const
  {
    if (!(op == rhs.op))
      return false;
    if (!(key == rhs.key))
      return false;
    if (!(value == rhs.value))
      return false;
    if (!(comment == rhs.comment))
      return false;
    if (!(successful == rhs.successful))
      return false;
    return true;
  }
  bool operator != (const Request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Request &a, Request &b);

inline std::ostream& operator<<(std::ostream& out, const Request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ProposalValue__isset {
  _ProposalValue__isset() : proposalNumber(false), request(false) {}
  bool proposalNumber : 1;
  bool request : 1;
} _ProposalValue__isset;

class ProposalValue {
public:

  ProposalValue(const ProposalValue&);
  ProposalValue& operator=(const ProposalValue&);
  ProposalValue() {
  }

  virtual ~ProposalValue() throw();
  ProposalNumber proposalNumber;
  Request request;

  _ProposalValue__isset __isset;

  void __set_proposalNumber(const ProposalNumber& val);

  void __set_request(const Request& val);

  bool operator == (const ProposalValue & rhs) const
  {
    if (!(proposalNumber == rhs.proposalNumber))
      return false;
    if (!(request == rhs.request))
      return false;
    return true;
  }
  bool operator != (const ProposalValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProposalValue &rhs) const {
    return this->proposalNumber.roundNumber < rhs.proposalNumber.roundNumber ||
           (this->proposalNumber.roundNumber == rhs.proposalNumber.roundNumber &&
            this->proposalNumber.serverID < rhs.proposalNumber.serverID);
  }

  bool operator > (const ProposalValue &rhs) const {
    return this->proposalNumber.roundNumber > rhs.proposalNumber.roundNumber ||
           (this->proposalNumber.roundNumber == rhs.proposalNumber.roundNumber &&
            this->proposalNumber.serverID > rhs.proposalNumber.serverID);
  }

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ProposalValue &a, ProposalValue &b);

inline std::ostream& operator<<(std::ostream& out, const ProposalValue& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ServerAddress__isset {
  _ServerAddress__isset() : port(false), hostname(false) {}
  bool port : 1;
  bool hostname : 1;
} _ServerAddress__isset;

class ServerAddress {
public:

  ServerAddress(const ServerAddress&);
  ServerAddress& operator=(const ServerAddress&);
  ServerAddress() : port(0), hostname() {
  }

  virtual ~ServerAddress() throw();
  int16_t port;
  std::string hostname;

  _ServerAddress__isset __isset;

  void __set_port(const int16_t val);

  void __set_hostname(const std::string& val);

  bool operator == (const ServerAddress & rhs) const
  {
    if (!(port == rhs.port))
      return false;
    if (!(hostname == rhs.hostname))
      return false;
    return true;
  }
  bool operator != (const ServerAddress &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ServerAddress &rhs) const {
    return this->hostname < rhs.hostname ||
           (this->hostname == rhs.hostname && this->port < rhs.port);
  }

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ServerAddress &a, ServerAddress &b);

inline std::ostream& operator<<(std::ostream& out, const ServerAddress& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _InvalidOperation__isset {
  _InvalidOperation__isset() : whatOp(false), why(false) {}
  bool whatOp : 1;
  bool why : 1;
} _InvalidOperation__isset;

class InvalidOperation : public ::apache::thrift::TException {
public:

  InvalidOperation(const InvalidOperation&);
  InvalidOperation& operator=(const InvalidOperation&);
  InvalidOperation() : whatOp(0), why() {
  }

  virtual ~InvalidOperation() throw();
  int32_t whatOp;
  std::string why;

  _InvalidOperation__isset __isset;

  void __set_whatOp(const int32_t val);

  void __set_why(const std::string& val);

  bool operator == (const InvalidOperation & rhs) const
  {
    if (!(whatOp == rhs.whatOp))
      return false;
    if (!(why == rhs.why))
      return false;
    return true;
  }
  bool operator != (const InvalidOperation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidOperation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(InvalidOperation &a, InvalidOperation &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidOperation& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
